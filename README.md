# Немного истории
## Язык программирования
Язык программирования, также как и наш естетсвенный язык, являеться возможностью взаимодействия, т.е комуникации. В контексте программирования это возможность управлять нашим компьютером с помощью наборов инструкций. Другим словом язык программирования это набор инструкций спомощью которых программист взаимодействует с компьютером. Что имеется под словом управлять? Так как наш компьютер это просто машина которая что то исполняет если мы ее попросим ввиде инструкций, т.е. наш компьютер не несет логики, ему непонятен механизм печати на консоль сообщения или вывод графики на экран монитора, т.е мы ему даем набор данных и инструкции что с этими данными делать и он их выполнет. Для управления и применяеться язык программирования, под самими словом программирования и скрываеться смысл, т.е. мы пытаемся запрограмировать что то для выполнения каких либо целей. С помощью языков программирования мы можем что то печать на экран, отображать графику на экране, выполнять сложные вычисления, отправлять по сети данные между несколькоми копьютерами. Для достижения этих целей мы и используем язык программирования как механизм управления компьютером. В наше время языков программирования очень много, правда есть заметные лидеры, которые очень популярные в среде комъюнити и эфективны. И тот или другой язык программирования явлеться эфективным для разных целей, нельзя например взять и сказать что этот язык может решить все, он например может но сложность будет высока решение этой проблемы, когда есть другой язык который явно специализируеться на решение этой проблемы.
## Машинные языки
Машинный язык это набор инструкций(опкод) котрорые выполняються непосредственно процессором. Основным составляющими нашего компьютера есть память и центральный процессор, в оперативной памяти храняться программа и данные которыми оперирует наша программа, при этом программа состоит из простых машинных кодах которые передаються в центральный процессор на выполнения и процессор понимает и умеет выполнять эти простые команды(например взять значение с одной ячейки памяти в регистр сложит с другой и записать в третью и т.д.). Т.е. изначально машинные программировались в таких машинных кодах, т.е. набор чисел которые записывались в память и выполнялись ЦП.
Машинный язык являеться платформо зависимым, т.е. на разной архитектуре(компьютере) набор инструкций или адресация могут быть разной. Т.е. говорят что процессор А совметим с процессором В, если процессор А полностью понимает машинный код процессора В. Машинный код есть нативный код, т.е. код который являеться родным для данной архитектуры компьютера. Инструкция это набор битов, и как следствие написание програм являлось трудоемким и долгим занятием, и плохо понимаемым другими программистами смысла этой программы. Также одна програма написанная на одной архитектуре, необходимо было переписывать под другую архитектуру(разные инструкции)
https://ru.bmstu.wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4
И как следствие этого писать такие программы было очень не удобно. И начали придумывать т.к. называемые языки программирования.
## Низкоуровневые языки
Машинные коды, в принципе есть самый низкоровневый язык. Но как было сказано запоминать команды(инструкции) в двоичном формате очень сложно, поэтому начали придумывать мнемоники(или так называемые англоязычные абриавиатуры, или сокращения английских слов). Так появился язык асемблер, в котором вместо двоичных команд используюеться английские абривиатуры команд и вместо адресации памяти используеться именования адрессов. Т.е. язык ассемблер стал более человекоподобным и более проще в сопровождении другими програмистами. Стоит заметить что язык асемблер на каждом процессоре разный, из за разных моделей процессора со своим набором команд, т.е. он также платформено зависимый(возможно команды одни и теже, но вот могут например отличяться регистры и т.д.)
Язык ассемблер это не есть машинный код, он являеться прослойкой для написания машинных команд, т.е. в нем используються десятичные цифры, строки и т.д. Для перевода языка ассемблера на машинный код используеться специальная программа транслятор называемая Ассемблером(с этого и пошло назвние языка ассемблер). Сам по себе язык ассемблера являеться высокопроизводительным так как он более близок к апаратной платформе.
Язык ассемблера считаеться языком второго поколения, т.к. машинные коды есть первый язык программирования.
Иногда при отладке приложений можно видеть ассемблерный код, где справой стороны это ассемблерные команды, а с левой стороны транслируемые обьектные коды(опкоды), т.е. каждая инструкция на языке асемблер соответствует машинному коду.
Проблема ассемблера, как было сказано выше из за его разности на разных процессорах, то что не существует единого стандарта на язык низкого уровня.
Также есть еще низкоуровневый язык это CIL(Common Intermediate Language). Это высоуровневый ассемблер для виртуальной машины .NET.
https://xakep.ru/2017/09/11/asm-course-1/
## Высокоуровневые языки
Вследствии того что языки низкого уровня являються архитектурно зависимыми, их трудно было переносить с одной архитектуры на другую, или переписывать после обновления апаратуры, т.е. на другой платформе переносимую программу необходимо было переписывать(т.е. отсутствувала кросплатформеность). Вторая проблема низкоуровневых языков это то что для понимания их кода, нужны были продвинутые программисты со знанием архитектуры и т.д., что было трудно для других инженеров, математиков. Так начали появляться первые высокоуровневые языки программирования(первым был язык FORTRAN в котором инструкции были более приблеженными к математике), целью которых было скрыть всю сложность низкоуровневых языков.
Суть высокоуровневых языков это некая абстракция, т.е. логически описанных конструкций, написание которых на машинном коде было бы очень длинным и сложным для понимания. Из этого следует что целью также высоуровневых языков это быстрота написания програм, т.е. изоляция от архитектурных зависимостей, а больше концентрация над тем что должна делать программа. Другой стороной ВЯ являеться ее портирование на разные платформы. Перевод на машинные коды(на платформенную зависимость) ложилось на плечи других программ так называемых трансляторов. Из этого вытекает что ВЯ являються менее эфективны чем НЯ, из за дополнительных промежуточных трансляций.
Один опереатор написанный на языке высокого уровня, может транслируеться в множетсво машиных кодов(в эру оптимизации компиляторов может быть немного все по другом, т.е. множество написанных операторов ВЯ может сконвертиться в одну интсрукцию машиного кода)
Иногда когда необходима эфективность низкоуровневого языка. в высокуровневый язык стали добывлять подержку низкоуровневых вставок(для эфективной работы с паматью, или работы напрямую с оборудуванием).
Иногда бывает так что ВЯ являються также платформено зависимыми, например системные вызовы или другие взаимодействия с ОС которые мошут отличаться от системы к системе. чаще такое программирование называют системным программировнием. Другим видом программирования являющемся платформено зависимым есть embedded system.
