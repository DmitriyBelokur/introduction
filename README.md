# Немного истории
## Язык программирования
Язык программирования, также как и наш естественный язык, является возможностью взаимодействия, т.е коммуникации. В контексте программирования это возможность управлять нашим компьютером с помощью наборов инструкций. Другим словом язык программирования это набор инструкций с помощью которых программист взаимодействует с компьютером. Что имеется под словом управлять? Так как наш компьютер это просто машина которая что то исполняет если мы ее попросим в виде инструкций, т.е. наш компьютер не несет логики, ему непонятен механизм печати на консоль сообщения или вывод графики на экран монитора, т.е мы ему даем набор данных и инструкции что с этими данными делать и он их выполняет. Для управления и применяется язык программирования, под самими словом программирования и скрывается смысл, т.е. мы пытаемся запрограммировать что то для выполнения каких либо целей. С помощью языков программирования мы можем что то печать на экран, отображать графику на экране, выполнять сложные вычисления, отправлять по сети данные между несколькими компьютерами. Для достижения этих целей мы и используем язык программирования как механизм управления компьютером. В наше время языков программирования очень много, правда есть заметные лидеры, которые очень популярные в среде комьюнити и эффективны. И тот или другой язык программирования является эффективным для разных целей, нельзя например взять и сказать что этот язык может решить все, он например может но сложность будет высока решение этой проблемы, когда есть другой язык который явно специализируется на решение этой проблемы.
## Машинные языки
Машинный язык это набор инструкций(опкод) которые выполнялись непосредственно процессором. Основным составляющими нашего компьютера есть память и центральный процессор, в оперативной памяти хранится программа и данные которыми оперирует наша программа, при этом программа состоит из простых машинных кодах которые передаются в центральный процессор на выполнения и процессор понимает и умеет выполнять эти простые команды(например взять значение с одной ячейки памяти в регистр сложит с другой и записать в третью и т.д.). Т.е. изначально машинные программировались в таких машинных кодах, т.е. набор чисел которые записывались в память и выполнялись ЦП.
Машинный язык является платформо независимым, т.е. на разной архитектуре(компьютере) набор инструкций или адресация могут быть разной. Т.е. говорят что процессор А совместим с процессором В, если процессор А полностью понимает машинный код процессора В. Машинный код есть нативный код, т.е. код который является родным для данной архитектуры компьютера. Инструкция это набор битов, и как следствие написание программ являлось трудоемким и долгим занятием, и плохо понимаемым другими программистами смысла этой программы. Также одна программа написанная на одной архитектуре, необходимо было переписывать под другую архитектуру(разные инструкции)
https://ru.bmstu.wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4
И как следствие этого, писать такие программы было очень не удобно. И начали придумывать т.к. называемые языки программирования.
## Низкоуровневые языки
Машинные коды, в принципе есть самый низкоуровневый язык. Но как было сказано запоминать команды(инструкции) в двоичном формате очень сложно, поэтому начали придумывать мнемоники(или так называемые англоязычные аббревиатуры, или сокращения английских слов). Так появился язык ассемблера, в котором вместо двоичных команд используются английские аббревиатуры команд и вместо адресации памяти используют именования адресов. Т.е. язык ассемблер стал более человекоподобным и более проще в сопровождении другими программистами. Стоит заметить что язык ассемблера на каждом процессоре разный, из за разных моделей процессора со своим набором команд, т.е. он также платформенно зависимый(возможно команды одни и те же, но вот могут например отличаться регистры и т.д.)
Язык ассемблер это не есть машинный код, он является прослойкой для написания машинных команд, т.е. в нем используются десятичные цифры, строки и т.д. Для перевода языка ассемблера на машинный код используется специальная программа транслятор называемая Ассемблером(с этого и пошло название языка ассемблер). Сам по себе язык ассемблера является высокопроизводительным так как он более близок к аппаратной платформе.
Язык ассемблера считался языком второго поколения, т.к. машинные коды есть первый язык программирования.
Иногда при отладке приложений можно видеть ассемблерный код, где с правой стороны это ассемблерные команды, а с левой стороны транслируемые объектные коды(опкоды), т.е. каждая инструкция на языке ассемблер соответствует машинному коду.
Проблема ассемблера, как было сказано выше из за его разности на разных процессорах, то что не существует единого стандарта на язык низкого уровня.
Также есть еще низкоуровневый язык это CIL(Common Intermediate Language). Это высокоуровневый ассемблер для виртуальной машины .NET.
https://xakep.ru/2017/09/11/asm-course-1/
## Высокоуровневые языки
Вследствии того что языки низкого уровня являються архитектурно зависимыми, их трудно было переносить с одной архитектуры на другую, или переписывать после обновления аппаратуры, т.е. на другой платформе переносимую программу необходимо было переписывать(т.е. отсутствовала кроссплатформенность). Вторая проблема низкоуровневых языков это то что для понимания их кода, нужны были продвинутые программисты со знанием архитектуры и т.д., что было трудно для других инженеров, математиков. Так начали появляться первые высокоуровневые языки программирования(первым был язык FORTRAN в котором инструкции были более приближенными к математике), целью которых было скрыть всю сложность низкоуровневых языков.
Суть высокоуровневых языков это некая абстракция, т.е. логически описанных конструкций, написание которых на машинном коде было бы очень длинным и сложным для понимания. Из этого следует что целью также высокоуровневых языков это быстрота написания программ, т.е. изоляция от архитектурных зависимостей, а больше концентрация над тем что должна делать программа. Другой стороной ВЯ является ее портирование на разные платформы. Перевод на машинные коды(на платформенную зависимость) ложилось на плечи других программ так называемых трансляторов. Из этого вытекает что ВЯ является менее эффективны чем НЯ, из за дополнительных промежуточных трансляций.
Один оператор написанный на языке высокого уровня, может транслируют в множество машинных кодов(в эру оптимизации компиляторов может быть немного все по другом, т.е. множество написанных операторов ВЯ может конвертиться в одну инструкцию машинного кода)
Иногда когда необходима эффективность низкоуровневого языка. в высокоуровневый язык стали добавлять поддержку низкоуровневых вставок(для эффективной работы с памятью, или работы напрямую с оборудованием).
Иногда бывает так что ВЯ является также платформенно зависимыми, например системные вызовы или другие взаимодействия с ОС которые могут отличаться от системы к системе. чаще такое программирование называют системным программированием. Другим видом программирования являющемся платформенно зависимым есть embedded system.
## Трансляторы
С одной стороны у нас есть программа написанная на языке высокого уровня, с другой стороны наш компьютер или система понимает только машинные коды, и соответственно нам необходим некий механизм перевода программы на языке высокого уровня в машинные коды. Для этих целей существуют трансляторы, это программы предназначены для трансляции кода на языке высокого уровня в машинный код(который может быть все чем угодно, например язык ассемблер, объектные файлы и т.д.). Другими словами транслятор это преобразование программы с одного языка в программу на другом языке.
Существуют следующие виды трансляции:
- компиляция
- интерпритация
- динамическая компиляция
### Компиляция
Компилятор это программа которая имплементирует язык программирования. Т.е. каждый язык программирования состоит из собственных компиляторов.
Простыми словами компилятор это транслятор языка высокого уровня в язык низкого уровня(это может быть язык ассемблер, или объектный файл, или машинные коды).
В компилятора есть понятие входа и есть понятие выхода, то что происходит в процессе компиляции и отличает его от других типов трансляции. На вход компилятор принимает исходный код нашей программы, а на выходе выдает exe файл или промежуточный(т.е. другую программу), который может быть разным в зависимости от типа компилятора(может быть как объектный файл, так и байт код и т.д.).
Немного истории первым компилятором был компилятор FORTRAN, его создать (после создания интерпретатора) хотел чтобы исходный код сразу транслировался в машинный код (т.е. работал быстрей). Немного резюмируя то компилятор это некая программа у которой есть два интерфейса первый это язык программирования, а второй это различные флаги, размер стека и т.д.
### Интерпритация
Другим видом трансляции является интерпретация исходного кода. Интерпретация программного кода выполняется последовательно строчка за строчкой программой называемой интерпретатором. Отличие интерпретатора от компилятора, как раз и состоит в том что происходит между входом и выходом, т.е как обрабатывать язык программирования. Если компилятор преобразует весь исходный код в машинный код, то интерпретатор будет выполнять это всякий раз когда мы будем запускать нашу программу. Или другими словами это можно назвать так, интерпретатор это как онлайн, а компилятор это как офлайн. Минусом интерпретатора есть то что на исполняющей системе должна быть всегда программа интерпретатор, это время выполнения каждой инструкции. Плюсом есть то что любая интерпретирующая программа является переносимой. Из этого следует то что заранее скомпилированный код работает намного быстрее, но есть зависимость исполняемого кода от аппаратной платформы. Это был пример простого интерпретатора, т.е. которые анализирует и сразу исполняет. Другой вид это так называемый интерпретатор компилирующего типа(байт коды), это компиляция, но в отличии от привычной компиляции где код транслируется сразу в машинный код, здесь трансляция происходит в промежуточный код(байт код), который затем исполняется(преобразуется в машинный код) так называемой виртуальной машиной(интерпретатором). Плюсом такого подхода есть быстродействие выполняемой программы(за счет выноса анализа исходного кода в отдельный разовый проход, и минимизация его в интерпретаторе), и переносимость программы так как нет прямой зависимости от архитектуры исполняемой системы. Недостатком это требования к ресурсам. Байт код это некий компромисс между компиляцией и интерпретацией. Другим видом есть JIT компиляция (just in time), т.е. компиляция во время выполнения. Т.е. подход раз скомпилирую и запускай где угодно был ресурсоемким, и был придуман механизм почему бы не компилировать код перед выполнением, т.е. сохраняется переносимость, но в тоже время происходит компиляция в нативный код, т.е виртуальная машина вызывает скомпилированный код вместо интерпретации его. JIT компиляция требует много процессорного времени и памяти, например некоторые инструкции кешируются для быстроты компиляции. На самом деле подход JIT применяеться для применение оптимизации(перестановка инструкций, удаление мертвого кода и т.д.) на этапе компиляции, как это притаманно обычной нативной компиляции.
## Парадигма программирования
Этот термин применяеться как метод для решение некоторых проблем или решение некоторых задач. Другими словами это некий подход к решению задачи, или иногда называют стиль решение проблемы(набор идей и понятий). Стоит уточнить что в наше время множество языков поддерживают много парадигм программирования, но если например язык C не поддерживает объектно ориентированную парадигму программирования это не значит что ее нельзя реализовать с помощью этого языка, вопрос в другом зачем?
Рассмотрим следующие парадигмы программирования:
- модульный
- структурный
- объектно ориентированный
### Модульный
Разбиение задачи происходит независимыми модулями, или иногда называют блоками. К примеру есть группа разработчиков которая работает над большей задачей, они разбивают эту задачу на небольшие модули которые могут разрабатываться независимо друг от друга, а потом например некоторые модули связываются между собой для решения задачи. Модуль это независимая единица трансляции, который может быть законченным фрагментом программы. Сам модуль внутри себя может содержать другую парадигму программирования. Удобство модуля заключается в том что вы можете модифицировать один из модулей не затрагиваю в целом систему. Иначе говоря модули реализую некий механизм инкапсуляции(принцип сокрытия данных). Модули также в некоторых языках программирования были заменены пакетами.
### Структурное программирование
Структурное программирование это первая реализация отказа от оператора goto, т.е. до СП все выглядело как спагетти код. Основным понятием СП есть блок(последовательность), ветвление, циклы, подпрограммы(повторяющиеся фрагменты) и при этом разработка идет сверху вниз. Т.е. резюмируя сказанное СП это такой подход который гарантирует более читаемый структуру программы, т.е. код становиться структурированным.
### Объектно ориентированное программирование
ООП более связано с нашей повседневной жизни, где все представлено классами и объектами этого класса(экземплярами). ООП также возникло как упрощенная модель написания кода, где ту или иную сущность можно представить в виде класса и объекта. ООП позволяет хранить некое состояние на всей протяжении жизни объекта. ООП она решает задачу структурного программирование,только на новом уровне. Т.е. ООП включает основные понятия:
- абстракция
- инкапсуляция
- наследование
- полиморфизм
- класс
- объект
 
Например есть класс FORD Mondeo, а конкретный автомобиль FORD Mondeo это экземпляр класса с неким состояние(пробег, царапины на кузове, и т.д.), при этом это состояние никак не пересекается с состояние других объектов этого же класса, они только могут обменяться этим состоянием(используя методы).
### Обобщенное программирование
Идея ОП заключаеться в том чтобы обобщить алгоритмы и структуры данных(списки, очереди и т.д.) в контексте разных типов, которые удовлетворяют тем или иным требованиям обобщенного алгоритма и структуры данных. Например функция обмена переменными(swap), заключаеться в том что тип обмениваемых переменных должен содержать оператор присваивания.
Простыми словами ОП это написание структур данных и алгоритмов которые могут работать с разными типами данных без изменения их описания(содержимого). Или можно часто слышать контекст что ОП являеться неким кодогенератором. Язык С++ содержит большую библиотеку обобщенных данных и обобщенных алгоритмов, которая называется STL(Standard Template Library).
## История С++
 ![](cpp_evolution.png)

История языка С++ начинаеться с 1980 х годов, который был придуман Бьёрном Страуструпом. Он пытался решить ряд задач, на то время существующими языками программирования, но каждый из них имел те или иные ограничения. Поэтому вспомнив работу над своей диссертацией, он начал работу над уже существующим популярным языком С (Деннисом Ритчи, являющимся многофункциональным и переносимым), который являлся базовым языком системы Unix. Страуструп добавил в язык С работу с классами, откуда и пошло первое название С с классами. Для этого была им написана утилита сfront - которая транслировала С с классами в язык С(мы видим еще один подход трансляции, а именно трансляция языка высокого уровня в язык высокого уровня). Но не ожидая того язык С++ начал набирать большую популярность среди общества, и в 1985 году была его первая коммерческая реализация. В него были включены виртуальные функции, константы, ссылки, более строгий контроль типов, перегрузка операторов. В связи с этим он был переименован в язык С++, т.е. язык С с улучшением. До 1998 г. не было единого стандарта по этому языку, и сам Страуструп поддерживал язык самостоятельно(документация и т.д.), но в 1998 был сформирован комитет задачей которого было формирование международного стандарта и в этом году был принят официальный стандарт. А в 2003 был принят новый стандарт, с незначительными изменениями.

https://en.cppreference.com/w/cpp/compiler_support

Как было сказано язык С является родителем языка С++, из этого следует что почти все программы на языке С есть программы языка С++(т.е. компилируется), но обратное не верно. TR( Library Technical Report 1) не является основной частью стандарта, это есть некоторое расширение стандартной библиотеки(регулярные выражение, генераторы случайных чисел и т.д.). До С++11 было приблизительно опубликовано 3 TR которые очень сильно повлияли на стандарт С++11
